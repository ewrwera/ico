Device driver books

𝐃𝐨𝐰𝐧𝐥𝐨𝐚𝐝 𝐡𝐞𝐫𝐞 ===> https://is.gd/8RtTnR?251424

.

.

.

.

.

.

.

.

.

.

.

.

Debuggers and Related Tools 4. Using gdb 4. The kdb Kernel Debugger 4. The kgdb Patches 4. The User-Mode Linux Port 4. The Linux Trace Toolkit 4. Dynamic Probes 5. Concurrency and Race Conditions 5. Pitfalls in scull 5. Concurrency and Its Management 5. Semaphores and Mutexes 5. The Linux Semaphore Implementation 5. Using Semaphores in scull 5. Completions 5. Spinlocks 5. Introduction to the Spinlock API 5.
Spinlocks and Atomic Context 5. The Spinlock Functions 5. Locking Traps 5. Ambiguous Rules 5. Lock Ordering Rules 5. Fine- Versus Coarse-Grained Locking 5. Alternatives to Locking 5. Lock-Free Algorithms 5. Atomic Variables 5. Bit Operations 5. Read-Copy-Update 5. Quick Reference 6. Advanced Char Driver Operations 6. Choosing the ioctl Commands 6. The Return Value 6. The Predefined Commands 6.
Using the ioctl Argument 6. Capabilities and Restricted Operations 6. The Implementation of the ioctl Commands 6. Device Control Without ioctl 6. Introduction to Sleeping 6.
Simple Sleeping 6. Blocking and Nonblocking Operations 6. Advanced Sleeping 6. How a process sleeps 6. Manual sleeps 6. Exclusive waits 6. The details of waking up 6. Testing the Scullpipe Driver 6. Interaction with read and write 6. Reading data from the device 6. Writing to the device 6. Flushing pending output 6. The Underlying Data Structure 6. Asynchronous Notification 6. Seeking a Device 6. The llseek Implementation 6. Access Control on a Device File 6. Single-Open Devices 6.
Restricting Access to a Single User at a Time 6. Cloning the Device on open 6. Quick Reference 7. Time, Delays, and Deferred Work 7. Measuring Time Lapses 7. Using the jiffies Counter 7. Processor-Specific Registers 7. Knowing the Current Time 7. Delaying Execution 7. Long Delays 7. Busy waiting 7.
Yielding the processor 7. Timeouts 7. Short Delays 7. Kernel Timers 7. The Timer API 7. The Implementation of Kernel Timers 7. Tasklets 7. Workqueues 7. The Shared Queue 7. Timekeeping 7. Delays 7. Workqueues 8. Allocating Memory 8. The Real Story of kmalloc 8. The Flags Argument 8.
Memory zones 8. The Size Argument 8. Lookaside Caches 8. A scull Based on the Slab Caches: scullc 8. Memory Pools 8. A scull Using Whole Pages: scullp 8.
A scull Using Virtual Addresses: scullv 8. Per-CPU Variables 8. Obtaining Large Buffers 8. Acquiring a Dedicated Buffer at Boot Time 8. Quick Reference 9. Communicating with Hardware 9. String Operations 9. Platform Dependencies 9.
An Overview of the Parallel Port 9. A Sample Driver 9. Quick Reference  Interrupt Handling  Preparing the Parallel Port  Installing an Interrupt Handler  Autodetecting the IRQ Number  Kernel-assisted probing  Do-it-yourself probing  Fast and Slow Handlers  The internals of interrupt handling on the x86  Implementing a Handler  Handler Arguments and Return Value  Enabling and Disabling Interrupts  Disabling a single interrupt  Disabling all interrupts  Top and Bottom Halves  Tasklets  Workqueues  Interrupt Sharing  Installing a Shared Handler  Running the Handler  A Write-Buffering Example  Data Types in the Kernel  Use of Standard C Types  Assigning an Explicit Size to Data Items  Interface-Specific Types  Other Portability Issues  Time Intervals  Page Size  Byte Order  Data Alignment  Pointers and Error Values  Linked Lists  PCI Drivers  The PCI Interface  PCI Addressing  Boot Time  Configuration Registers and Initialization  Registering a PCI Driver  Enabling the PCI Device  Accessing the Configuration Space  PCI Interrupts  Hardware Abstractions  Hardware Resources  ISA Programming  The Plug-and-Play Specification  Our focus has been to show all the features available to device driver writers in 2.
This edition of the book does not cover prior versions of the kernel. For those of you who are interested, the second edition covered Versions 2. Kernel programmers should be aware that the development process changed with 2.
The 2. Among other things, that means that internal kernel programming interfaces can change, thus potentially obsoleting parts of this book; for this reason, the sample code accompanying the text is known to work with 2.
Programmers wanting to keep up with kernel programming changes are encouraged to join the mailing lists and to make use of the web sites listed in the bibliography. General users never have a reason to run development kernels. Developers experimenting with new features, however, want to be running the latest development release. They usually keep upgrading to the most recent version to pick up bug fixes and new implementations of features.
This book is platform independent as far as possible, and all the code samples have been tested on at least the x86 and x platforms. Because the code has been tested on both bit and bit processors, it should compile and run on all other platforms.
The GPL allows anybody to redistribute, and even sell, a product covered by the GPL, as long as the recipient has access to the source and is able to exercise the same rights. Additionally, any software product derived from a product covered by the GPL must, if it is redistributed at all, be released under the GPL.
The main goal of such a license is to allow the growth of knowledge by permitting everybody to modify programs at will; at the same time, people selling software to the public can still do their job. If you want to read the license, you can find it in several places in your system, including the top directory of your kernel source tree in the COPYING file. Vendors often ask whether they can distribute kernel modules in binary form only. The answer to that question has been deliberately left ambiguous.
Distribution of binary modules—as long as they adhere to the published kernel interface—has been tolerated so far. But the copyrights on the kernel are held by many developers, and not all of them agree that kernel modules are not derived products. If you or your employer wish to distribute kernel modules under a nonfree license, you really need to discuss the situation with your legal counsel.
Please note also that the kernel developers have no qualms against breaking binary modules between kernel releases, even in the middle of a stable kernel series. If it is at all possible, both you and your users are better off if you release your module as free software.
If you want your code to go into the mainline kernel, or if your code requires patches to the kernel, you must use a GPL-compatible license as soon as you release the code. As you begin writing modules for the Linux kernel, you become part of a larger community of developers. Within that community, you can find not only people engaged in similar work, but also a group of highly committed engineers working toward making Linux a better system.
These people can be a source of help, ideas, and critical review as well—they will be the first people you will likely turn to when you are looking for testers for a new driver. The central gathering point for Linux kernel developers is the linux-kernel mailing list. All major kernel developers, from Linus Torvalds on down, subscribe to this list. Please note that the list is not for the faint of heart: traffic as of this writing can run up to messages per day or more.
Nonetheless, following this list is essential for those who are interested in kernel development; it also can be a top-quality resource for those in need of kernel development help. Read the rest of the FAQ while you are at it; there is a great deal of useful information there.
Linux kernel developers are busy people, and they are much more inclined to help people who have clearly done their homework first. From here on, we enter the world of kernel programming. Chapter 2 introduces modularization, explaining the secrets of the art and showing the code for running modules. Chapter 3 talks about char drivers and shows the complete code for a memory-based device driver that can be read and written for fun.
Using memory as the hardware base for the device allows anyone to run the sample code without the need to acquire special hardware. Debugging techniques are vital tools for the programmer and are introduced in Chapter 4.
Equally important for those who would hack on contemporary kernels is the management of concurrency and race conditions. Chapter 5 concerns itself with the problems posed by concurrent access to resources and introduces the Linux mechanisms for controlling concurrency. With debugging and concurrency management skills in place, we move to advanced features of char drivers, such as blocking operations, the use of select , and the important ioctl call; these topics are the subject of Chapter 6.
Next we focus on hardware. Unfortunately, not everyone is able to run the sample code for these chapters, because some hardware support is actually needed to test the software interface interrupts.
Chapter 11 covers the use of data types in the kernel and the writing of portable code. The second half of the book is dedicated to more advanced topics. We start by getting deeper into the hardware and, in particular, the functioning of specific peripheral buses. With an understanding of peripheral buses in place, we can take a detailed look at the Linux device model, which is the abstraction layer used by the kernel to describe the hardware and software resources it is managing.
Chapter 14 is a bottom-up look at the device model infrastructure, starting with the kobject type and working up from there. It covers the integration of the device model with real hardware; it then uses that knowledge to cover topics like hot-pluggable devices and power management.
In Chapter 15 , we take a diversion into Linux memory management. Our understanding of memory will be useful for the following two chapters, which cover the other major driver classes. Chapter 16 introduces block drivers and shows how they are different from the char drivers we have worked with so far.
Then Chapter 17 gets into the writing of network drivers. We finish up with a discussion of serial drivers and a bibliography. We discuss capabilities in Chapter 6. Skip to main content.
Start your free trial. Chapter 1. An Introduction to Device Drivers. The Role of the Device Driver. Splitting the Kernel. Process management The kernel is in charge of creating and destroying processes and handling their connection to the outside world input and output. Filesystems Unix is heavily based on the filesystem concept; almost everything in Unix can be treated as a file. Device control Almost every system operation eventually maps to a physical device.
Networking Networking must be managed by the operating system, because most network operations are not specific to a process: incoming packets are asynchronous events. Loadable Modules. Classes of Devices and Modules. Character devices A character char device is one that can be accessed as a stream of bytes like a file ; a char driver is in charge of implementing this behavior.
Network interfaces Any network transaction is made through an interface, that is, a device that is able to exchange data with other hosts. To configure your kernel, either use make menuconfig for an ncurse-based interface or make xconfig for an X-based interface.
Once chosen, options will be stored in a. In most cases, there will be no need to start a configuration from scratch. There are default and useful configuration files available in each arch directory, which you can use as a starting point:. It is quite straightforward for an x86 system:. Given an i. With the former command, you will store the default option in the.
You may run into a Qt4 error with xconfig. In such a case, you should just use the following command:. Building the kernel requires you to specify the architecture for which it is built, as well as the compiler.
That said, it is not necessary for a native build:. Modules are built with the following command:. This is discussed in Chapter 2, Device Driver Basis. MX6 processors support device trees, which are files you use to describe the hardware this is discussed in detail in Chapter 6 , The Concept of Device Tree.
To compile every ARCH device tree, you can run the following command:. However, the dtbs option is not available on all platforms that support device tree. To build a standalone DTB, you should use:. The kernel code tried to follow standard rules throughout its evolution. In this chapter, we will just be introduced to them. They are all discussed in a dedicated chapter; starting from Chapter 3 , Kernel Facilities and Helper Functions, we get a better overview of the kernel development process and tips, up to Chapter 13 , Linux Device Model.
This coding style is a set of rules you should respect, at least if you need to get patches accepted by kernel developers. Some of these rules concern indentation, program flow, naming conventions, and so on. The kernel always offers two possible allocation mechanisms for its data structures and facilities. Data structures that represent framework devices are always allocated dynamically, each having its own allocation and deallocation API.
These framework device types are:. The scope of the static objects is visible in the whole driver, and by every device this driver manages. Dynamically allocated objects are visible only by the device that is actually using a given instance of the module. The kernel implements OOP by means of a device and a class.
Kernel subsystems are abstracted by means of classes. The struct kobject structure is the centerpiece of this implementation. It even brings in a reference counter, so that the kernel may know how many users actually use the object.